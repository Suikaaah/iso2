type bool = False | True
type 'a option = None | Some of 'a
type ('a, 'e) result = Ok of 'a | Error of 'e
type 'a list = Nil (* [] *) | Cons (* :: *) of 'a * 'a list
type nat = Z (* 0 *) | S (* n *) of nat

iso rec last = case
  | [] <-> (None, [])
  | [x] <-> (Some x, [x])
  | x :: y :: t <->
      let (opt, y :: t) = last (y :: t) in
      (opt, x :: y :: t)
in

[Ok None; Error None]

