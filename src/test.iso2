type bool            = False | True
type 'a option       = None | Some of 'a
type ('l, 'r) either = Left of 'l | Right of 'r
type 'a list         = Nil (* [] *) | Cons (* :: *) of 'a * 'a list
type nat             = Z (* 0 *) | S (* n *) of nat
type q               = Init | Next | Flip | Done | Back | Final
type s               = B | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7

iso compose g f = case x <->
  let x = f x in
  let x = g x in x
in

iso rec len = case
| [] <-> ([], 0)
| h :: t <->
  let (t, n) = len t in
  (h :: t, S n)
in

iso rec snoc' = case
| ([], x, 0) <-> ([x], x, 0)
| (h :: t, x, S n) <->
  let (t, x, n) = snoc' (t, x, n) in
  (h :: t, x, S n)
in

iso snoc = case (x, y) <->
  let (x, n) = len x in
  let (x, y, n) = snoc' (x, y, n) in
  let z = inv len (x, S n) in
  (z, y)
in

iso rec rev' = case
| ([], y) <-> ([], y)
| (h :: t, y) <->
  let (h1, h2) = (h, h) in
  let (t1, t2) = rev' (t, h2 :: y) in
  (h1 :: t1, t2)
in

iso rev = case x <-> let x = rev' (x, []) in x in

iso growth = case (l, r) <->
  let (l, B) = snoc (l, B) in
  let (r, B) = snoc (r, B) in
  (l, r)
in

iso delta = case
(* (Init, (B, B), Next) *)
| (Init, (x', B, y')) <->
  let (l, r) = growth (x', y') in
  ((Next, (l, B, r)), False)

(* (Next, ->, Flip) *)
| (Next, (x', z, y :: y')) <->
  let (l, r) = growth (x', y') in
  ((Flip, (z :: l, y, r)), False)

(* (Flip, (S0, S1), Next) *)
| (Flip, (x', S0, y')) <->
  let (l, r) = growth (x', y') in
  ((Next, (l, S1, r)), False)

(* (Flip, (S1, S0), Next) *)
| (Flip, (x', S1, y')) <->
  let (l, r) = growth (x', y') in
  ((Next, (l, S0, r)), False)

(* (Flip, (S2, S2), Back) *)
| (Flip, (x', S2, y')) <->
  let (l, r) = growth (x', y') in
  ((Back, (l, S2, r)), False)

(* (Back, <-, Done) *)
| (Back, (x :: x', z, y')) <->
  let (l, r) = growth (x', y') in
  ((Done, (l, x, z :: r)), False)

(* (Done, (S0, S0), Back) *)
| (Done, (x', S0, y')) <->
  let (l, r) = growth (x', y') in
  ((Back, (l, S0, r)), False)

(* (Done, (S1, S1), Back) *)
| (Done, (x', S1, y')) <->
  let (l, r) = growth (x', y') in
  ((Back, (l, S1, r)), False)

(* (Done, (B, B), Final) *)
| (Done, (x', B, y')) <->
  let (l, r) = growth (x', y') in
  ((Final, (l, B, r)), True)
in

iso delta_inv = case
(* (Next, (B, B), Init) *)
| (Next, (x', B, y')) <->
  let (l, r) = growth (x', y') in
  ((Init, (l, B, r)), True)

(* (Flip, <-, Next) *)
| (Flip, (x :: x', z, y')) <->
  let (l, r) = growth (x', y') in
  ((Next, (l, x, z :: r)), False)

(* (Next, (S1, S0), Flip) *)
| (Next, (x', S1, y')) <->
  let (l, r) = growth (x', y') in
  ((Flip, (l, S0, r)), False)

(* (Next, (S0, S1), Flip) *)
| (Next, (x', S0, y')) <->
  let (l, r) = growth (x', y') in
  ((Flip, (l, S1, r)), False)

(* (Back, (S2, S2), Flip) *)
| (Back, (x', S2, y')) <->
  let (l, r) = growth (x', y') in
  ((Flip, (l, S2, r)), False)

(* (Done, ->, Back) *)
| (Done, (x', z, y :: y')) <->
  let (l, r) = growth (x', y') in
  ((Back, (z :: l, y, r)), False)

(* (Back, (S0, S0), Done) *)
| (Back, (x', S0, y')) <->
  let (l, r) = growth (x', y') in
  ((Done, (l, S0, r)), False)

(* (Back, (S1, S1), Done) *)
| (Back, (x', S1, y')) <->
  let (l, r) = growth (x', y') in
  ((Done, (l, S1, r)), False)

(* (Final, (B, B), Done) *)
| (Final, (x', B, y')) <->
  let (l, r) = growth (x', y') in
  ((Done, (l, B, r)), False)
in

iso rec rm_blank = case
| []      <-> ([], 0)
| B :: t  <-> let (t, n) = rm_blank t in (t, S n)
| S0 :: t <-> (S0 :: t, 0)
| S1 :: t <-> (S1 :: t, 0)
| S2 :: t <-> (S2 :: t, 0)
| S3 :: t <-> (S3 :: t, 0)
| S4 :: t <-> (S4 :: t, 0)
| S5 :: t <-> (S5 :: t, 0)
| S6 :: t <-> (S6 :: t, 0)
| S7 :: t <-> (S7 :: t, 0)
in

iso clean_up = case ((x, (l, y, r)), n) <->
  let (l, n1) = rm_blank l in
  let (r_ori, r_rev) = rev r in
  let (r, n2) = rm_blank r_rev in
  ((x, (l, y, r)), (n, n1, n2, r_ori))
in

iso rec it f = case x <->
  let y = f x in
  let z = match y with
    | (y, False) <-> let (y, n) = it f y in (y, S n)
    | (y, True)  <-> (y, 0)
  in z
in

iso garbrem f g = case x <->
  let (x, y) = f x in
  let (x, z) = (x, x) in
  let x = inv f (x, y) in
  let (z, y) = g z in
  let (z, z) = (z, x) in
  let z = inv g (z, y) in
  z
in

iso compute = garbrem
  {compose clean_up {it delta}}
  {compose clean_up {it delta_inv}}
in

compute (Init, ([], B, [S0; S1; S1; S2]))

