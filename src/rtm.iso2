type nat     = Z (* 0 *) | S (* n *) of nat
type 'a list = Nil (* [] *) | Cons (* :: *) of 'a * 'a list
type bool    = False | True

(* states *)
type q = Init | Next | Flip | Done | Back | Final

(* symbols *)
type s = B | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7

(* push_back (x, y) = x @ [y] *)
iso rec push_back = case
| ([], y)      <-> [y]
| (x :: xs, y) <->
  let y :: xs = push_back (xs, y) in
  x :: y :: xs
in

(* extend (x, y) = (x @ [B], y @ [B]) *)
iso extend = case (x, y) <->
  let x = push_back (x, B) in
  let y = push_back (y, B) in (x, y)
in

(* transitions *)
iso delta extend = case
(* (Init, (B, B), Next) *)
| (Init, (l, B, r)) <->
  let (l, r) = extend (l, r) in
  (Next, (l, B, r))

(* (Next, ->, Flip) *)
| (Next, (l, s, s' :: r)) <->
  let (l, r) = extend (l, r) in
  (Flip, (s :: l, s', r))

(* (Flip, (S0, S1), Next) *)
| (Flip, (l, S0, r)) <->
  let (l, r) = extend (l, r) in
  (Next, (l, S1, r))

(* (Flip, (S1, S0), Next) *)
| (Flip, (l, S1, r)) <->
  let (l, r) = extend (l, r) in
  (Next, (l, S0, r))

(* (Flip, (B, B), Back) *)
| (Flip, (l, B, r)) <->
  let (l, r) = extend (l, r) in
  (Back, (l, B, r))

(* (Back, <-, Done) *)
| (Back, (s' :: l, s, r)) <->
  let (l, r) = extend (l, r) in
  (Done, (l, s', s :: r))

(* (Done, (S0, S0), Back) *)
| (Done, (l, S0, r)) <->
  let (l, r) = extend (l, r) in
  (Back, (l, S0, r))

(* (Done, (S1, S1), Back) *)
| (Done, (l, S1, r)) <->
  let (l, r) = extend (l, r) in
  (Back, (l, S1, r))

(* (Done, (B, B), Final) *)
| (Done, (l, B, r)) <->
  let (l, r) = extend (l, r) in
  (Final, (l, B, r))
in

(* adds a boolean indicating termination *)
iso delta_fwd = case conf <->
  let conf = delta extend conf in
  let conf_bool = match conf with
    | (Init, t)  <-> ((Init, t), False)
    | (Next, t)  <-> ((Next, t), False)
    | (Flip, t)  <-> ((Flip, t), False)
    | (Done, t)  <-> ((Done, t), False)
    | (Back, t)  <-> ((Back, t), False)
    | (Final, t) <-> ((Final, t), True)
  in conf_bool
in

(* now Init is the final state *)
iso delta_bwd = case conf <->
  let conf = inv delta extend conf in
  let conf_bool = match conf with
    | (Init, t)  <-> ((Init, t), True)
    | (Next, t)  <-> ((Next, t), False)
    | (Flip, t)  <-> ((Flip, t), False)
    | (Done, t)  <-> ((Done, t), False)
    | (Back, t)  <-> ((Back, t), False)
    | (Final, t) <-> ((Final, t), False)
  in conf_bool
in

(* rm_blank x = (<x w/o trailing n blanks>, n) *)
iso rec rm_blank = case
| []      <-> ([], 0)
| B  :: t <-> let ([], n) = rm_blank t in ([], S n)
| S0 :: t <-> let (t, n)  = rm_blank t in (S0 :: t, n)
| S1 :: t <-> let (t, n)  = rm_blank t in (S1 :: t, n)
| S2 :: t <-> let (t, n)  = rm_blank t in (S2 :: t, n)
| S3 :: t <-> let (t, n)  = rm_blank t in (S3 :: t, n)
| S4 :: t <-> let (t, n)  = rm_blank t in (S4 :: t, n)
| S5 :: t <-> let (t, n)  = rm_blank t in (S5 :: t, n)
| S6 :: t <-> let (t, n)  = rm_blank t in (S6 :: t, n)
| S7 :: t <-> let (t, n)  = rm_blank t in (S7 :: t, n)
in

(* clean_up (c, garb) = (<c w/o unnecessary blanks>, garb') *)
iso clean_up = case ((x, (l, y, r)), n) <->
  let (l, n1) = rm_blank l in
  let (r, n2) = rm_blank r in
  ((x, (l, y, r)), (n, n1, n2))
in

(* applies f (n + 1) times *)
(* returns the result and n *)
iso rec iter f = case x <->
  let x = f x in
  let x = match x with
    | (x, False) <-> let (x, n) = iter f x in (x, S n)
    | (x, True)  <-> (x, 0)
  in x
in

(* Bennett's trick *)
iso rm_garb f g = case x <->
  let (x, y) = f x in
  let (x, z) = (x, x) in
  let x = inv f (x, y) in
  let (z, y) = g z in
  let (z, z) = (z, x) in
  let z = inv g (z, y) in z
in

(* compose g f x = g (f x) *)
iso compose g f = case x <->
  let x = f x in
  let x = g x in x
in

(* stdconf <-> stdconf *)
iso compute = rm_garb
  {compose clean_up {iter delta_fwd}}
  {compose clean_up {iter delta_bwd}}
in

(* tape <-> tape *)
iso sem = case tape <->
  let (Final, ([], B, tape)) =
    compute (Init, ([], B, tape)) in tape
in

sem [S0; S1; S1; S0; S1; S0]

