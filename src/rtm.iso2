type bool            = False | True
type 'a option       = None | Some of 'a
type ('l, 'r) either = Left of 'l | Right of 'r
type 'a list         = Nil (* [] *) | Cons (* :: *) of 'a * 'a list
type nat             = Z (* 0 *) | S (* n *) of nat

(* states *)
type q = Init | Next | Flip | Done | Back | Final

(* symbols *)
type s = B | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7

(* len x = (x, <length of x>) *)
iso rec len = case
| [] <-> ([], 0)
| x :: xs <->
  let (xs, n) = len xs in
  (x :: xs, S n)
in

iso rec snoc' = case
| ([], x, 0) <-> ([x], x, 0)
| (h :: t, x, S n) <->
  let (t, x, n) = snoc' (t, x, n) in
  (h :: t, x, S n)
in

(* snoc (x, y) = (x @ [y], y) *)
iso snoc = case (x, y) <->
  let (x, n) = len x in
  let (x, y, n) = snoc' (x, y, n) in
  let z = inv len (x, S n) in
  (z, y)
in

(* growth (x, y) = (x @ [B], y @ [B]) *)
iso growth = case (x, y) <->
  let (x, B) = snoc (x, B) in
  let (y, B) = snoc (y, B) in
  (x, y)
in

(* transitions *)
iso delta growth = case
(* (Init, (B, B), Next) *)
| (Init, (x', B, y')) <->
  let (l, r) = growth (x', y') in
  (Next, (l, B, r))

(* (Next, ->, Flip) *)
| (Next, (x', z, y :: y')) <->
  let (l, r) = growth (x', y') in
  (Flip, (z :: l, y, r))

(* (Flip, (S0, S1), Next) *)
| (Flip, (x', S0, y')) <->
  let (l, r) = growth (x', y') in
  (Next, (l, S1, r))

(* (Flip, (S1, S0), Next) *)
| (Flip, (x', S1, y')) <->
  let (l, r) = growth (x', y') in
  (Next, (l, S0, r))

(* (Flip, (S2, S2), Back) *)
| (Flip, (x', S2, y')) <->
  let (l, r) = growth (x', y') in
  (Back, (l, S2, r))

(* (Back, <-, Done) *)
| (Back, (x :: x', z, y')) <->
  let (l, r) = growth (x', y') in
  (Done, (l, x, z :: r))

(* (Done, (S0, S0), Back) *)
| (Done, (x', S0, y')) <->
  let (l, r) = growth (x', y') in
  (Back, (l, S0, r))

(* (Done, (S1, S1), Back) *)
| (Done, (x', S1, y')) <->
  let (l, r) = growth (x', y') in
  (Back, (l, S1, r))

(* (Done, (B, B), Final) *)
| (Done, (x', B, y')) <->
  let (l, r) = growth (x', y') in
  (Final, (l, B, r))
in

iso delta_fwd = case x <->
  let d = delta growth x in
  let d = match d with
    | (Init, x) <-> ((Init, x), False)
    | (Next, x) <-> ((Next, x), False)
    | (Flip, x) <-> ((Flip, x), False)
    | (Done, x) <-> ((Done, x), False)
    | (Back, x) <-> ((Back, x), False)
    | (Final, x) <-> ((Final, x), True)
  in d
in

iso delta_bwd = case x <->
  let d = inv delta growth x in
  let d = match d with
    | (Init, x) <-> ((Init, x), True)
    | (Next, x) <-> ((Next, x), False)
    | (Flip, x) <-> ((Flip, x), False)
    | (Done, x) <-> ((Done, x), False)
    | (Back, x) <-> ((Back, x), False)
    | (Final, x) <-> ((Final, x), False)
  in d
in

(* rm_blank_f x = (<x w/o leading n blanks>, n) *)
iso rec rm_b_front = case
| []      <-> ([], 0)
| B :: t  <-> let (t, n) = rm_b_front t in (t, S n)
| S0 :: t <-> (S0 :: t, 0)
| S1 :: t <-> (S1 :: t, 0)
| S2 :: t <-> (S2 :: t, 0)
| S3 :: t <-> (S3 :: t, 0)
| S4 :: t <-> (S4 :: t, 0)
| S5 :: t <-> (S5 :: t, 0)
| S6 :: t <-> (S6 :: t, 0)
| S7 :: t <-> (S7 :: t, 0)
in

(* rm_blank_b x = (<x w/o trailing n blanks>, n) *)
iso rec rm_b_back = case
| []      <-> ([], 0)
| B :: t  <-> let ([], n) = rm_b_back t in ([], S n)
| S0 :: t <-> let (t, n) = rm_b_back t in (S0 :: t, n)
| S1 :: t <-> let (t, n) = rm_b_back t in (S1 :: t, n)
| S2 :: t <-> let (t, n) = rm_b_back t in (S2 :: t, n)
| S3 :: t <-> let (t, n) = rm_b_back t in (S3 :: t, n)
| S4 :: t <-> let (t, n) = rm_b_back t in (S4 :: t, n)
| S5 :: t <-> let (t, n) = rm_b_back t in (S5 :: t, n)
| S6 :: t <-> let (t, n) = rm_b_back t in (S6 :: t, n)
| S7 :: t <-> let (t, n) = rm_b_back t in (S7 :: t, n)
in

(* clean_up (c, garb) = (<c w/o unnecessary blanks>, garb') *)
iso clean_up = case ((x, (l, y, r)), n) <->
  let (l, n1) = rm_b_front l in
  let (r, n2) = rm_b_back r in
  ((x, (l, y, r)), (n, n1, n2))
in

(* applies f (n + 1) times *)
(* returns the result and n *)
iso rec iter f = case x <->
  let y = f x in
  let z = match y with
    | (y, False) <-> let (y, n) = iter f y in (y, S n)
    | (y, True)  <-> (y, 0)
  in z
in

(* Bennett's trick *)
iso rm_garb f g = case x <->
  let (x, y) = f x in
  let (x, z) = (x, x) in
  let x = inv f (x, y) in
  let (z, y) = g z in
  let (z, z) = (z, x) in
  let z = inv g (z, y) in
  z
in

iso compose g f = case x <->
  let x = f x in
  let x = g x in x
in

iso compute = rm_garb
  {compose clean_up {iter delta_fwd}}
  {compose clean_up {iter delta_bwd}}
in

iso str_sem = case tape <->
  let (Final, ([], B, tape)) =
    compute (Init, ([], B, tape)) in tape
in

str_sem [S0; S1; S1; S0; S0; S2]

