type nat     = Z (* 0 *) | S (* n *) of nat
type 'a list = Nil (* [] *) | Cons (* :: *) of 'a * 'a list
type bool    = False | True

(* states *)
type q = Init | Next | Flip | Done | Back | Final

(* symbols *)
type s = B | A0 | A1 | A2 | A3

(* push_back (x, y) = x @ [y] *)
iso rec push_back = case
| ([], y)      <-> [y]
| (x :: xs, y) <->
  let y :: xs = push_back (xs, y) in
  x :: y :: xs
in

(* extend (x, y) = (x @ [B], y @ [B]) *)
iso extend = case (x, y) <->
  let x = push_back (x, B) in
  let y = push_back (y, B) in (x, y)
in

(* transitions *)
iso delta extend = case
(* (Init, (B, B), Next) *)
| (Init, (l, B, r)) <->
  let (l, r) = extend (l, r) in
  (Next, (l, B, r))

(* (Next, ->, Flip) *)
| (Next, (l, s, s' :: r)) <->
  let (l, r) = extend (l, r) in
  (Flip, (s :: l, s', r))

(* (Flip, (A0, A1), Next) *)
| (Flip, (l, A0, r)) <->
  let (l, r) = extend (l, r) in
  (Next, (l, A1, r))

(* (Flip, (A1, A0), Next) *)
| (Flip, (l, A1, r)) <->
  let (l, r) = extend (l, r) in
  (Next, (l, A0, r))

(* (Flip, (B, B), Back) *)
| (Flip, (l, B, r)) <->
  let (l, r) = extend (l, r) in
  (Back, (l, B, r))

(* (Back, <-, Done) *)
| (Back, (s' :: l, s, r)) <->
  let (l, r) = extend (l, r) in
  (Done, (l, s', s :: r))

(* (Done, (A0, A0), Back) *)
| (Done, (l, A0, r)) <->
  let (l, r) = extend (l, r) in
  (Back, (l, A0, r))

(* (Done, (A1, A1), Back) *)
| (Done, (l, A1, r)) <->
  let (l, r) = extend (l, r) in
  (Back, (l, A1, r))

(* (Done, (B, B), Final) *)
| (Done, (l, B, r)) <->
  let (l, r) = extend (l, r) in
  (Final, (l, B, r))
in

(* adds a boolean indicating termination *)
iso delta_fwd = case conf <->
  let conf = delta extend conf in
  let conf_bool = match conf with
    | (Init, t)  <-> ((Init, t), False)
    | (Next, t)  <-> ((Next, t), False)
    | (Flip, t)  <-> ((Flip, t), False)
    | (Done, t)  <-> ((Done, t), False)
    | (Back, t)  <-> ((Back, t), False)
    | (Final, t) <-> ((Final, t), True)
  in conf_bool
in

(* now Init is the final state *)
iso delta_bwd = case conf <->
  let conf = inv delta extend conf in
  let conf_bool = match conf with
    | (Init, t)  <-> ((Init, t), True)
    | (Next, t)  <-> ((Next, t), False)
    | (Flip, t)  <-> ((Flip, t), False)
    | (Done, t)  <-> ((Done, t), False)
    | (Back, t)  <-> ((Back, t), False)
    | (Final, t) <-> ((Final, t), False)
  in conf_bool
in

(* rm_blank x = (<x w/o trailing n blanks>, n) *)
iso rec rm_blank = case
| []      <-> ([], 0)
| B  :: t <-> let ([], n) = rm_blank t in ([], S n)
| A0 :: t <-> let (t, n)  = rm_blank t in (A0 :: t, n)
| A1 :: t <-> let (t, n)  = rm_blank t in (A1 :: t, n)
| A2 :: t <-> let (t, n)  = rm_blank t in (A2 :: t, n)
| A3 :: t <-> let (t, n)  = rm_blank t in (A3 :: t, n)
in

(* clean_up (c, garb) = (<c w/o unnecessary blanks>, garb') *)
iso clean_up = case ((x, (l, y, r)), n) <->
  let (l, n1) = rm_blank l in
  let (r, n2) = rm_blank r in
  ((x, (l, y, r)), (n, n1, n2))
in

(* applies f (n + 1) times *)
(* returns the result and n *)
iso rec iter f = case x <->
  let x = f x in
  let x = match x with
    | (x, False) <-> let (x, n) = iter f x in (x, S n)
    | (x, True)  <-> (x, 0)
  in x
in

(* Bennett's trick *)
iso rm_garb f g = case i <->
  let (o, gb) = f i in
  let (o, o') = (o, o) in
  let i = inv f (o, gb) in
  let (i', gb) = g o' in
  let (i, i) = (i, i') in
  let o = inv g (i, gb) in o
in

(* compose g f x = g (f x) *)
iso compose g f = case x <->
  let x = f x in
  let x = g x in x
in

(* stdconf <-> stdconf *)
iso compute = rm_garb
  {compose clean_up {iter delta_fwd}}
  {compose clean_up {iter delta_bwd}}
in

(* tape <-> tape *)
iso sem = case tape <->
  let (Final, ([], B, tape)) =
    compute (Init, ([], B, tape)) in tape
in

sem [A0; A1; A1; A0; A1; A0]

