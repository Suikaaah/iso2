type bool            = False | True
type 'a option       = None | Some of 'a
type ('l, 'r) either = Left of 'l | Right of 'r
type ('a, 'e) result = Ok of 'a | Error of 'e
type 'a list         = Nil (* [] *) | Cons (* :: *) of 'a * 'a list
type nat             = Z (* 0 *) | S (* n *) of nat

iso rec merge leq = case
| ([], [])           <-> ([], [])
| (x :: xs, [])      <-> (x :: xs, [False])
| ([], y :: ys)      <-> (y :: ys, [True])
| (x :: xs, y :: ys) <->
  let (xs, g :: g' :: gs) = match (leq (x, y), xs, ys) with
    | ((True, (x, y)), xs, ys) <->
      let (merged, g) = merge leq (xs, y :: ys) in
      (x :: merged, False :: g)
    | ((False, (x, y)), xs, ys) <->
      let (merged, g) = merge leq (x :: xs, ys) in
      (y :: merged, True :: g)
  in (xs, g :: g' :: gs)
in

iso rec nat_leq = case
| (0, S n)   <-> (True, (0, S n))
| (S m, 0)   <-> (False, (S m, 0))
| (0, 0)     <-> (True, (0, 0))
| (S m, S n) <-> let (b, (m, n)) = nat_leq (m, n) in (b, (S m, S n))
in

merge nat_leq ([2;5;6], [1;3;4;7;8])

