type bool = False | True
type 'a option = None | Some of 'a
type ('a, 'e) result = Ok of 'a | Error of 'e
type 'a list = Nil (* [] *) | Cons (* :: *) of 'a * 'a list
type nat = Z (* 0 *) | S (* n *) of nat
type ord = Lt | Eq | Gt

iso rec len = case
  | [] <-> (0, [])
  | x :: xs <-> let (n, xs) = len xs in (S n, x :: xs)
in

iso rec map f = case
  | h :: t <->
      let h = f h in
      let t = map f t in
      h :: t
  | [] <-> []
in

iso rec last = case
  | [] <-> (None, [])
  | [x] <-> (Some x, [x])
  | x :: y :: t <->
      let (opt, y :: t) = last (y :: t) in
      (opt, x :: y :: t)
in

iso rec double = case
  | [] <-> []
  | x :: xs <->
      let xs = double xs in
      x :: x :: xs
in

iso rec rev = case
  | (l, (0, [])) <-> (l, (0, []))
  | (l, (S n, x :: xs)) <->
      let (l, (n, xs)) = rev (x :: l, (n, xs)) in
      (l, (S n, xs))
in

iso rev = case l <->
  let p = len l in
  let (l, (n, [])) = rev ([], p) in
  let l = invert len (n, l) in l
in

iso rec fold_left f = case
  | (acc, []) <-> (acc, [])
  | (acc, x :: xs) <->
      let (x, x') = (x, x) in
      let acc = f (acc, x) in
      let (acc, xs) = fold_left f (acc, xs) in
      (acc, x' :: xs)
in

iso rec repeat = case
  | (0, x) <-> ([], x)
  | (S n, x) <->
      let (xs, x) = repeat (n, x) in
      (x :: xs, x)
in

iso rec split = case
  | [] <-> ([], [])
  | (x, y) :: tl <->
      let (xs, ys) = split tl in
      (x :: xs, y :: ys)
in

iso merge = invert split in

()
