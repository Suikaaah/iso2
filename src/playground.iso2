iso swap = case (x, y) <-> (y, x) in
iso id = case x <-> x in
iso dup = case x <-> (x, x) in

iso rec list_map f = case
  | h :: t <->
      let h = f h in
      let t = list_map f t in
      h :: t
  | [] <-> []
in

(* add (x, y) = (x + y, y) *)
iso rec add = case
  | (m, S n) <->
      let m = S m in
      let (m, n) = add (m, n) in
      (m, S n)
  | (m, 0) <-> (m, 0)
in

iso rec cantor_pairing = case
  | x <->
      let y = match x with
        | (S i, j) <-> Some (i, S j)
        | (0, S j) <-> Some (j, 0)
        | (0, 0)   <-> None
      in
      let z = match y with
        | Some x <-> let y = cantor_pairing x in S y
        | None   <-> 0
      in z
in

iso option_map f = case
  | None   <-> None
  | Some x <-> let y = f x in Some y
in

iso compose g f = case
  | x <->
      let x = f x in
      let x = g x in
      x
in

iso rec len = case
  | [] <-> ([], 0)
  | h :: t <->
      let (t, n) = len t in
      (h :: t, S n)
in

iso rec snoc' = case
  | ([], x, 0) <-> ([x], x, 0)
  | (h :: t, x, S n) <->
      let (t, x, n) = snoc' (t, x, n) in
      (h :: t, x, S n)
in

iso snoc = case
  | (x, y) <->
      let (x, n) = len x in
      let (x, y, n) = snoc' (x, y, n) in
      let n = S n in
      let z = invert len (x, n) in
      (z, y)
in

iso rec rev_aux = case
  | ([], y) <-> ([], y)
  | (h :: t, y) <->
      let (h1, h2) = dup h in
      let c = h2 :: y in
      let (t1, t2) = rev_aux (t, c) in
      (h1 :: t1, t2)
in

iso rev = case
  | x <->
      let l = match x with x <-> (x, []) in
      let (t1, t2) = rev_aux l in
      (t1, t2)
in

iso rec double = case
  | [] <-> []
  | x :: xs <->
      let xs = double xs in
      x :: x :: xs
in

iso if then else = case
  | (True, x) <-> let x = then x in (True, x)
  | (False, x) <-> let x = else x in (False, x)
in

iso if then else = case
  | x <-> let x = if then else x in x
in

let hi = S 3 :: S 4 :: S 5 :: [let x = 2 in x] in

if double {list_map S} (True, hi)
