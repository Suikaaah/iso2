type bool = False | True
type 'a option = None | Some of 'a
type ('a, 'e) result = Ok of 'a | Error of 'e
type 'a list = Nil (* [] *) | Cons (* :: *) of 'a * 'a list
type nat = Z (* 0 *) | S (* n *) of nat

(* -------- nat -------- *)

iso rec is_even = case
  | 0 <-> (0, True)
  | 1 <-> (1, False)
  | S (S x) <-> let (x, b) = is_even x in (S (S x), b)
in

(* add (x, y) = (x + y, y) *)
iso rec add = case
  | (m, S n) <-> let (m, n) = add (S m, n) in (m, S n)
  | (m, 0) <-> (m, 0)
in

iso rec cantor_pairing = case x <->
  let y = match x with
    | (S i, j) <-> Some (i, S j)
    | (0, S j) <-> Some (j, 0)
    | (0, 0)   <-> None
  in
  let z = match y with
    | Some x <-> let y = cantor_pairing x in S y
    | None   <-> 0
  in z
in

(* -------- misc -------- *)

iso option_map f = case
  | None   <-> None
  | Some x <-> let y = f x in Some y
in

iso compose g f = case x <->
  let x = f x in
  let x = g x in x
in

iso if then else = case
  | (True, x) <-> let x = then x in (True, x)
  | (False, x) <-> let x = else x in (False, x)
in

(* -------- list -------- *)

iso rec list_map f = case
  | h :: t <->
      let h = f h in
      let t = list_map f t in
      h :: t
  | [] <-> []
in

iso rec len = case
  | [] <-> ([], 0)
  | x :: xs <-> let (xs, n) = len xs in (x :: xs, S n)
in

iso rec snoc' = case
  | ([], x, 0) <-> ([x], x, 0)
  | (h :: t, x, S n) <->
      let (t, x, n) = snoc' (t, x, n) in
      (h :: t, x, S n)
in

iso snoc = case (x, y) <->
  let (x, n) = len x in
  let (x, y, n) = snoc' (x, y, n) in
  let z = invert len (x, S n) in
  (z, y)
in

iso rec double = case
  | [] <-> []
  | x :: xs <->
      let xs = double xs in
      x :: x :: xs
in

iso rec rev = case
  | ([], l, 0) <-> ([], l, 0)
  | (x :: xs, l, S n) <->
      let (xs, l, n) = rev (xs, x :: l, n) in
      (xs, l, S n)
in

iso rev = case l <->
  let (l, n) = len l in
  let ([], l, n) = rev (l, [], n) in
  let l = invert len (l, n) in
  l
in

iso rec fold_left f = case
  | (acc, []) <-> (acc, [])
  | (acc, x :: xs) <->
      let (x, x') = (x, x) in
      let acc = f (acc, x) in
      let (acc, xs) = fold_left f (acc, xs) in
      (acc, x' :: xs)
in

fold_left (case (acc, x) <-> x :: acc) ([], [1; 2; 3; 4])

