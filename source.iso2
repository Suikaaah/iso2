type nat = 0 | S of nat
type opt = None | Some of (nat, nat)

let iso aux =
  iso : (nat, nat) <-> opt.
  | (S i, j)   <-> Some (i, S j)
  | (0, S S j) <-> Some (S j, 0)
  | (0, S 0)   <-> Some (0, 0)
  | (0, 0)     <-> None
in

let iso cantor_pairing =
  fix phi : (nat, nat) <-> nat.
    iso : (nat, nat) <-> nat.
    | x <-> let y = aux x in
            let z =
              (iso : opt <-> nat.
              | Some x <-> let y = phi x in S y
              | None   <-> 0) y in z
in

let x = (S S 0, S 0) in
let y = cantor_pairing x in
(y, (invert cantor_pairing) y)
